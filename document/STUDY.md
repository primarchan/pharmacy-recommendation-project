### Spring Data JPA 란?
> - JPA 란 Java 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
> - Spring Data JPA 는 Spring 에서 제공하는 모듈 중 하나로, 개발자가 JPA 를 더 쉽고 편하게 사용할 수 있도록 도와준다.
> - <b>JPA 를 한 단계 추상화시킨 Repository 인터페이스 제공</b>
> - build.gradle 의존성 추가 및 인터페이스만 정의해주게 되면 JPA 의 CRUD 를 바로 사용 가능
> - <b>단, 영속성 컨텍스트 및 Dirty Checking 개념을 잘 이해하고 사용하지 않으면 데이터 손실 및 성능 이슈가 발생할 수 있다.</b>
<hr>

### Spring Data JPA 사용 시 주의사항
> - <b>`JPA` 의 모든 데이터 변경은 아래와 같이 트랜잭션 안에서 실행된다.</b>
> - <b>즉, 트랜잭션 밖에서 데이터 변경은 반영되지 않는다.</b>
> - `Spring Data JPA` 구현 코드를 살펴보면, 변경이 일어나는 코드는 `@Transactional` 이 이미 추가되어 있다.
> - 즉, 구현 코드를 정확히 이해하지 않고 사용시 문제가 발생할 수 있다.
<hr>

### 영속성 컨텍스트 (Persistence Context)
> - 영속성 컨텍스트는 엔티티를 저장하고 관리하는 저장소이며, 어플리케이션과 데이터베이스 사이에 entity 를 보관하는 가상의 데이터베이스 같은 역할
> - <b>`Spring Data JPA` 에서 제공하는 `save` 메서드 구현 코드를 보면 `em.persist` 를 통해 영속성 컨텍스트에 저장</b>
> - <b>이때, 엔티티는 영속상태</b>
> - 이미 영속상태인 경우 `merge` 를 통해 덮어쓴다.
<hr>

### 영속성 컨텍스트를 왜 사용할까?
> - Database 와 어플리케이션 사이의 중간 계층에 있으면서 여러가지 이점이 있다.
> - 영속성 컨텍스트 내에 1차 캐시
> - 영속성 컨텍스트 내에 쓰기 지연 SQL 저장소
> - 엔티티 수정 (`Dirty Checking`)
<hr>

### 영속성 컨텍스트 - 1차 캐시
> - 영속성 컨텍스트 내부에 1차 캐시를 가지고 있다.
> - persist 를 하는 순간 PK 값 (ID), 타입과 객체를 맵핑하여 1차 캐시에 가지고 있음
> - <b>한 트랜잭션 내에 1차 캐시에 이미있는 값을 조회하는 경우, DB 를 조회하지 않고 1차 캐시에 있는 내용을 그대로 가져온다.</b>
> - 단, 1차 캐시는 어플리케이션 전체 공유가 아닌 한 트랜잭션 내에서만 공유
> - 반면, 조회했을 때 1차 캐시에 없다면 DB 에서 가져와서 1차 캐시에 저장 후 반환
> ```Java
> // 엔티티를 생성한 상태 (비영속)
> Member member = new Member();
> member.setId("member1");
> member.setUsername("회원1");
> 
> // 엔티티를 영속
> em.persist();
> ```
<hr>

### 영속성 컨텍스트 - 쓰기 지연 SQL
> - `memberA` 를 `persist` 하는 순간, 1차 캐시에 넣고 쓰기를 지연 SQL 저장소에 쿼리를 만들어 쌓는다.
> - `memberB` 도 `persist` 하는 순간, 동일한 과정을 거치며, <b>`commit` 하는 순간 `flush` 가 되면서 DB 에 반영</b>
> - `flush` 란 영속성 컨텍스트의 변경 내용을 DB 에 반영하며, 1차 캐시를 지우지는 않는다.

